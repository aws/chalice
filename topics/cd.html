
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Continuous Deployment (CD) &#8212; AWS Chalice</title><link rel="stylesheet" href="../_static/bootstrap-reboot.css" type="text/css" />
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/default.css" />
    <link rel="stylesheet" href="../_static/custom-tabs.css" type="text/css" />
    

    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script type="text/javascript">
        function _scroll(subjectId) {
            var subjectElement = $(subjectId);
            var actualSubjectHeight = subjectElement.height();
            var startingPosition = subjectElement[0].getBoundingClientRect().top;
            return function() {
                var availableHeight = $(window).height() - startingPosition;
                // Subtract the scroll position to account for sticky movement.
                availableHeight += Math.min($(window).scrollTop(), 40);
                var cappedHeight = Math.min(actualSubjectHeight, availableHeight);
                if (subjectElement.css("height") !== cappedHeight) {
                    subjectElement.css("height", cappedHeight);
                }
            };
        }

        // Scroll and resize the the columns when scrolled.
        $(function() {
            var rightScroll = _scroll("#right-column > .column-body");
            var scrollFn = function() {
                rightScroll.call(this, arguments);
            };
            scrollFn();
            $(window).scroll(scrollFn);
            $(window).resize(scrollFn);
        });

        // Scroll spy to change highlighted navigation element.
        $(function() {
            var section = document.querySelectorAll(".section");
            var sections = {};
            var i = 0;
            Array.prototype.forEach.call(section, function(e) {
                sections[e.id] = e.offsetTop;
            });
            var scrollSpy = function() {
                var scrollPosition = document.documentElement.scrollTop || document.body.scrollTop;
                for (i in sections) {
                    if (sections[i] <= scrollPosition) {
                        $('#right-column .current').removeClass('current');
                        $("#right-column a[href='#" + i + "']").addClass('current');
                    }
                }
            };
            $(window).scroll(scrollSpy);
            scrollSpy();
        });
    </script>
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-168492171-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-168492171-3');
    </script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Custom Domain Names" href="domainname.html" />
    <link rel="prev" title="Websockets" href="websockets.html" />
  <!-- Licensed under the Apache 2.0 License -->
  <link rel="stylesheet" type="text/css" href="../_static/fonts/open-sans/stylesheet.css" />
  
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">


  </head><body>
    <header>
        <div class="header-flex width-wrapper">
            <div class="site-logo">
                <a href="../index.html">
		  <span class="logo-icon"><img src="../_static/img/chalice-logo-icon-small.png" /></span>
                </a>
            </div>

            <ul id="page-navigation">
                <li class="site-page first"><a href="../quickstart.html">Quick Start</a></li>
                <li class="site-page"><a href="../tutorials/index.html">Tutorials</a></li>
                <li class="site-page"><a href="../samples/index.html">Samples</a></li>
                <li class="site-page"><a href="../main.html">Documentation</a></li>
                <li class="site-page"><a href="https://github.com/aws/chalice">Code</a></li>
                <li class="site-search hidden-sm">
                    <form action="../search.html" method="get">
                        <input type="hidden" name="check_keywords" value="yes" />
                        <input type="hidden" name="area" value="default" />
                        <input class="search-input" autocomplete="off" type="search" name="q" placeholder="Search" />
                    </form>
                </li>
            </ul>
        </div>
    </header>
    
        
        
        <section id="page-container">
            <div class="width-wrapper flex">
                <article id="document-body">
                    
                    <ul class="rel-parents">
                    <li><a href="index.html" accesskey="U">Topics</a></li>
                    </ul>
                    
                    
  <section id="continuous-deployment-cd">
<h1>Continuous Deployment (CD)<a class="headerlink" href="#continuous-deployment-cd" title="Permalink to this headline">¶</a></h1>
<p>Chalice can be used to set up a basic Continuous Deployment pipeline. The
<code class="docutils literal notranslate"><span class="pre">chalice</span> <span class="pre">deploy</span></code> command is good for getting up and running quickly with
Chalice, but in a team environment properly managing permissions and sharing
and updating the <code class="docutils literal notranslate"><span class="pre">deployed.json</span></code> file will get messy.</p>
<p>One way to scale up your chalice app is to create a continuous deployment
pipeline. The pipeline can run tests on code changes and, if they pass, promote
the new build to a testing stage. More checks can be put in place to manually
promote a build to production, or you can do so automatically. This model
greatly simplifies managing what resources belong to your Chalice app as they
are all stored in the Continuous Deployment pipeline.</p>
<p>Chalice can generate a CloudFormation template that will create a starter CD
pipeline. By default it contains an AWS CodeCommit repo, an AWS CodeBuild stage
for packaging your chalice app, and an AWS CodePipeline stage to deploy your
application using CloudFormation.</p>
<p>You can also configure a source repository hosted on GitHub instead of
a CodeCommit repository.</p>
<section id="pipeline-template-versions">
<h2>Pipeline Template Versions<a class="headerlink" href="#pipeline-template-versions" title="Permalink to this headline">¶</a></h2>
<p>This starter pipeline template can be generated using the <code class="docutils literal notranslate"><span class="pre">generate-pipeline</span></code>
command.  There are two versions of this pipeline.  The older <code class="docutils literal notranslate"><span class="pre">v1</span></code> template
is the default (for backwards compatibility reasons), but the newer template
version, <code class="docutils literal notranslate"><span class="pre">v2</span></code>, is recommended.  The version can be specified using the
<code class="docutils literal notranslate"><span class="pre">--pipeline-version</span></code> option.  These are the differences between <code class="docutils literal notranslate"><span class="pre">v1</span></code> and
<code class="docutils literal notranslate"><span class="pre">v2</span></code> templates:</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">v1</span></code> templates use version <code class="docutils literal notranslate"><span class="pre">0.1</span></code> of the CodeBuild buildspec, whereas
<code class="docutils literal notranslate"><span class="pre">v2</span></code> uses <code class="docutils literal notranslate"><span class="pre">0.2</span></code> of the CodeBuild buildspec.  Buildspec <code class="docutils literal notranslate"><span class="pre">0.2</span></code> is the
recommended version to use with CodeBuild.  See their
<a class="reference external" href="https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html">documentation</a>
for more information.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">v2</span></code> template uses <a class="reference external" href="https://aws.amazon.com/secrets-manager/">AWS Secrets Manager</a>
to configure access to a GitHub repository.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">v2</span></code> buildspec uses <a class="reference external" href="https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html#build-spec.phases.install.runtime-versions">runtime-versions</a>
to configure which version of Python to use instead of a Python
version specific CodeBuild image.  For <code class="docutils literal notranslate"><span class="pre">v2</span></code> templates the
<code class="docutils literal notranslate"><span class="pre">aws/codebuild/amazonlinux2-x86_64-standard</span></code> image.</p></li>
</ul>
<p><strong>The v2 pipeline template requires Python 3.7 or higher.</strong> If you’re using
Python versions less than 3.7 you must use the <code class="docutils literal notranslate"><span class="pre">v1</span></code> pipeline template.</p>
</section>
<section id="usage-example">
<h2>Usage example<a class="headerlink" href="#usage-example" title="Permalink to this headline">¶</a></h2>
<p>Setting up the deployment pipeline is a two step process. First use the
<code class="docutils literal notranslate"><span class="pre">chalice</span> <span class="pre">generate-pipeline</span></code> command to generate a base CloudFormation
template. Second use the AWS CLI to deploy the CloudFormation template using
the <code class="docutils literal notranslate"><span class="pre">aws</span> <span class="pre">cloudformation</span> <span class="pre">deploy</span></code> command. Below is an example.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ chalice generate-pipeline --pipeline-version v2 pipeline.json
$ aws cloudformation deploy --stack-name mystack
      --template-file pipeline.json --capabilities CAPABILITY_IAM
Waiting for changeset to be created..
Waiting for stack create/update to complete
Successfully created/updated stack - mystack
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To configure your Chalice app to use a GitHub repository instead of
CodeCommit see the <a class="reference internal" href="#cicd-github-repo"><span class="std std-ref">Configuring a GitHub Repository</span></a> section below.</p>
</div>
<p>Once the CloudFormation template has finished creating the stack, you will have
several new AWS resources that make up a bare bones CD pipeline.</p>
<ul class="simple">
<li><p><strong>CodeCommit Repository</strong> - The <a class="reference external" href="https://aws.amazon.com/codecommit/">CodeCommit</a>
repository is the entrypoint into the pipeline. Any code you want to deploy
should be pushed to this remote.</p></li>
<li><p><strong>CodePipeline Pipeline</strong> - The
<a class="reference external" href="https://aws.amazon.com/codepipeline/">CodePipeline</a> is what coordinates
the build process, and pushes the released code out.</p></li>
<li><p><strong>CodeBuild Project</strong> - The <a class="reference external" href="https://aws.amazon.com/codebuild/">CodeBuild</a>
project is where the code bundle is built that will be pushed to Lambda. The
default CloudFormation template will create a CodeBuild stage that builds
a package using <code class="docutils literal notranslate"><span class="pre">chalice</span> <span class="pre">package</span></code> and then uploads those artifacts for
CodePipeline to deploy.</p></li>
<li><p><strong>S3 Buckets</strong> - Two S3 buckets are created on your behalf.</p>
<ul>
<li><p><strong>artifactbucketstore</strong> - This bucket stores artifacts that are built by
the CodeBuild project. The only artifact by default is the
<code class="docutils literal notranslate"><span class="pre">transformed.yaml</span></code> created by the <code class="docutils literal notranslate"><span class="pre">aws</span> <span class="pre">cloudformation</span> <span class="pre">package</span></code> command.</p></li>
<li><p><strong>applicationbucket</strong> - Stores the application bundle after the Chalice
application has been packaged in the CodeBuild stage.</p></li>
</ul>
</li>
<li><p>Each resource is created with all the required IAM roles and policies.</p></li>
</ul>
<section id="codecommit-repository">
<h3>CodeCommit repository<a class="headerlink" href="#codecommit-repository" title="Permalink to this headline">¶</a></h3>
<p>The CodeCommit repository can be added as a git remote for deployment. This
makes it easy to kick off deployments. The developer doing the deployment only
needs to push the release code up to the CodeCommit repository master branch.
All the developer needs is keys that allow for push access to the CodeCommit
repository. This is a lot easier than managing a set of <code class="docutils literal notranslate"><span class="pre">deployed.json</span></code>
resources across a repsoitory and manually doing <code class="docutils literal notranslate"><span class="pre">chalice</span> <span class="pre">deploy</span></code> whenever
a change needs to be deployed.</p>
<p>The default CodeCommit repository that is created is empty, you will have to
populate it with the Chalice application code. Permissions will also need to be
set up, you can find the documentation on how to do that
<a class="reference external" href="https://docs.aws.amazon.com/codebuild/latest/userguide/setting-up.html">here</a>
.</p>
<p>You can retrieve the CodeCommit clone URL by searching for the
<code class="docutils literal notranslate"><span class="pre">SourceRepoURL</span></code> in the CloudFormation stack output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ aws cloudformation describe-stacks --stack-name mystack \
   --query &quot;Stacks[0].Outputs[?OutputKey==&#39;SourceRepoURL&#39;] | [0].OutputValue&quot;
</pre></div>
</div>
</section>
<section id="id1">
<h3>CodePipeline<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>CodePipeline is the main coordinator between all the other resources. It
watches for changes on the CodeCommit repository, and triggers builds in the
CodeBuild project. If the build succeeds then it will start a CloudFormation
deployment of the built artifacts to a beta stage. This should be treated as
a starting point, not a fully featured CD system.</p>
</section>
<section id="codebuild-build-script">
<h3>CodeBuild build script<a class="headerlink" href="#codebuild-build-script" title="Permalink to this headline">¶</a></h3>
<p>By default Chalice will create the CodeBuild project with a default buildspec
that does the following.</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">0.1</span>
<span class="nt">phases</span><span class="p">:</span>
<span class="w">  </span><span class="nt">install</span><span class="p">:</span>
<span class="w">    </span><span class="nt">commands</span><span class="p">:</span>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">sudo pip install --upgrade awscli</span>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">aws --version</span>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">sudo pip install chalice</span>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">sudo pip install -r requirements.txt</span>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">chalice package /tmp/packaged</span>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">aws cloudformation package --template-file</span>
<span class="w">        </span><span class="l l-Scalar l-Scalar-Plain">/tmp/packaged/sam.json --s3-bucket ${APP_S3_BUCKET}</span>
<span class="w">        </span><span class="l l-Scalar l-Scalar-Plain">--output-template-file transformed.yaml</span>
<span class="nt">artifacts</span><span class="p">:</span>
<span class="w">  </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">zip</span>
<span class="w">  </span><span class="nt">files</span><span class="p">:</span>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">transformed.yaml</span>
</pre></div>
</div>
<p>The CodeBuild stage installs both the AWS CLI and Chalice, then creates a
package out of your chalice project, pushing the package to the application
S3 bucket that was created for you. The transformed CloudFormation template
is the only artifact, and can be run by CodePipeline after the build has
succeeded.</p>
</section>
<section id="deploying-to-beta-stage">
<h3>Deploying to beta stage<a class="headerlink" href="#deploying-to-beta-stage" title="Permalink to this headline">¶</a></h3>
<p>Once the CodeBuild stage has finished building the Chalice package and
creating the <code class="docutils literal notranslate"><span class="pre">transformed.yaml</span></code>, CodePipeline will take these artifacts and
use them to create or update the beta stage. The <code class="docutils literal notranslate"><span class="pre">transformed.yaml</span></code>
is a CloudFormation template that CodePipeline will execute, all the code it
references has been uploaded to the application bucket by the AWS CLI in the
CodeBuild stage, so this is the only artifact we need.</p>
<p>Once the CodePipeline beta build stage is finished, the beta version of the app
is deployed and ready for testing.</p>
</section>
<section id="extending">
<h3>Extending<a class="headerlink" href="#extending" title="Permalink to this headline">¶</a></h3>
<p>It is recommended to use this pipeline as a starting point. The default
template does not run any tests on the Chalice app before deploying to beta.
There is also no mechanism provided by Chalice for a production stage.
Ideally the CodeBuild stage would be used to run unit and functional tests
before deploying to beta. After the beta stage is up, integration tests can be
run against that endpoint, and if they all pass the beta stage could be
promoted to a production stage using the CodePipeline manual approval feature.</p>
</section>
</section>
<section id="configuring-a-github-repository">
<span id="cicd-github-repo"></span><h2>Configuring a GitHub Repository<a class="headerlink" href="#configuring-a-github-repository" title="Permalink to this headline">¶</a></h2>
<p>You can configure a GitHub repository instead of a CodeCommit repo when
setting up your deployment pipeline by specifying the <code class="docutils literal notranslate"><span class="pre">--source</span> <span class="pre">github</span></code>
option.  When generating a CloudFormation template for a GitHub repository,
there are several parameters that are added to your template that allow
you to configure how to connect your GitHub repository with your CodePipeline.</p>
<p>You must store your OAuth token that enables access to a GitHub repository
in AWS Secrets Manager.  You then specify the secret name/id and the JSON
key name as CloudFormation parameters.  These values default to a secret
name of <code class="docutils literal notranslate"><span class="pre">GithubRepoAccess</span></code> and a JSON key name of <code class="docutils literal notranslate"><span class="pre">OAuthToken</span></code>.</p>
<p>Below is an example of how to configure a GitHub repository as the
source for your deployment pipeline.</p>
<p>First create a <a class="reference external" href="https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token">GitHub token</a>
that can be used in this template.  Next create a secret in AWS Secrets
Manager.  You can either follow the documentation
<a class="reference external" href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/manage_create-basic-secret.html">here</a>
or use the AWS CLI or any AWS SDK.  For this example, we’ll use the AWS CLI
to create our secret.  Create a file named <code class="docutils literal notranslate"><span class="pre">/tmp/secrets.json</span></code> with these
contents:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s2">&quot;OAuthToken&quot;</span><span class="p">:</span> <span class="s2">&quot;abcdefghhijklmnop&quot;</span><span class="p">}</span>
</pre></div>
</div>
<p>Be sure to replace the value of <code class="docutils literal notranslate"><span class="pre">OAuthToken</span></code> with the value of your GitHub
token you created.  Next we can create the secret using this command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ aws secretsmanager create-secret --name GithubRepoAccess \
  --description &quot;Token for Github Repo Access&quot; \
  --secret-string file:///tmp/secrets.json
</pre></div>
</div>
<p>Now we can generate our deployment pipeline:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ chalice generate-pipeline --pipeline-version v2 \
  --source github --buildspec-file buildspec.yml pipeline.json
</pre></div>
</div>
<p>This will create two files, a <code class="docutils literal notranslate"><span class="pre">pipeline.json</span></code> file containing our
deployment pipeline and a <code class="docutils literal notranslate"><span class="pre">buildspec.yml</span></code> file.  This buildspec file
lets us update what commands should be run as part of our build process
without having to redeploy our CloudFormation template.</p>
<p>We now add and commit our changes to our repository.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ git add buildspec.yml pipeline.json
$ git commit -m &quot;Add deployment pipeline template&quot;
$ git push
</pre></div>
</div>
<p>Now we’re ready to deploy our CloudFormation template using the AWS CLI.  Be
sure to replace the <code class="docutils literal notranslate"><span class="pre">GithubOwner</span></code> and <code class="docutils literal notranslate"><span class="pre">GithubRepoName</span></code> with your own
values for your GitHub repository.  You’ll also need to specify the
<code class="docutils literal notranslate"><span class="pre">GithubRepoSecretId</span></code> and <code class="docutils literal notranslate"><span class="pre">GithubRepoSecretJSONKey</span></code> if you used values
other than the default vaues of <code class="docutils literal notranslate"><span class="pre">GithubRepoAccess</span></code> and <code class="docutils literal notranslate"><span class="pre">OAuthToken</span></code> when
creating your secret in Secrets Manager.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ aws cloudformation deploy --template-file pipeline.json \
  --stack-name MyChaliceApp --parameter-overrides \
  GithubOwner=repo-owner-name \
  GithubRepoName=repo-name \
  --capabilities CAPABILITY_IAM
</pre></div>
</div>
<p>We’ve now created a deployment pipeline that will automatically deploy our
Chalice app whenever we push to our GitHub repository.</p>
</section>
</section>


                    
                    <section class="relations">
                        
                        <a href="websockets.html" title="previous chapter" class="previous-page clearfix hidden-xs">← Websockets</a>
                        
                        <a href="domainname.html" title="next chapter" class="next-page clearfix">Custom Domain Names →</a>
                    </section>
                    
                </article><aside id="right-column" class="side-column hidden-sm">
                    <div class="column-body">
                        <section class="sidebar">
                            
                            <section class="next-previous">
                                
                                <a href="websockets.html" title="previous chapter" class="previous-page clearfix hidden-xs">← Prev</a>
                                
                                <a href="domainname.html" title="next chapter" class="next-page clearfix">Next →</a>
                            </section>
                            
                            <ul>
<li><a class="reference internal" href="#">Continuous Deployment (CD)</a><ul>
<li><a class="reference internal" href="#pipeline-template-versions">Pipeline Template Versions</a></li>
<li><a class="reference internal" href="#usage-example">Usage example</a><ul>
<li><a class="reference internal" href="#codecommit-repository">CodeCommit repository</a></li>
<li><a class="reference internal" href="#id1">CodePipeline</a></li>
<li><a class="reference internal" href="#codebuild-build-script">CodeBuild build script</a></li>
<li><a class="reference internal" href="#deploying-to-beta-stage">Deploying to beta stage</a></li>
<li><a class="reference internal" href="#extending">Extending</a></li>
</ul>
</li>
<li><a class="reference internal" href="#configuring-a-github-repository">Configuring a GitHub Repository</a></li>
</ul>
</li>
</ul>

                        </section>
                    </div>
                </aside></div>
        </section>
        
    
<footer id="footer">
    <div class="width-wrapper">
        <div class="copyright">
            <p>©2020, Amazon Web Services, Inc or its affiliates. All rights reserved.</p>
        </div>
    </div>
</footer>
  </body>
</html>